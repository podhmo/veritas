# アプローチの比較: JSON vs Goコード生成

`veritas`ライブラリにおける検証ルールの提供方法として、2つの主要なアプローチが考えられます。1つは現在実装されている、ルールをJSONファイルとして生成・ロードする方法です。もう1つは、ルールをGoのソースコードとして直接生成する方法です。

このドキュメントでは、両方のアプローチを具体的なコード例と共に比較し、将来的な方針を検討します。

---

## 比較の前提となるGoの構造体

以下の `models.User` 構造体をインプットとして、各アプローチがどのようにルールを扱い、利用するかを見ていきます。

```go
// file: models/user.go
package models

// @cel: self.Password == self.PasswordConfirm
type User struct {
    Name     string `validate:"required,cel:self.size() < 50"`
    Age      int    `validate:"cel:self >= 18"`
    Password string `validate:"required"`
    PasswordConfirm string `validate:"required"`
}
```

---

## 1. JSONアプローチ (現在の手法)

CLIツールがGoのソースコードを静的解析し、検証ルールをJSONファイルに出力します。アプリケーションは実行時にこのJSONファイルを読み込みます。

### 生成されるファイル (`rules.json`)

`veritas -in ./models -out rules.json` を実行すると、以下のJSONが生成されます。

```json
{
  "models.User": {
    "typeRules": [
      "self.Password == self.PasswordConfirm"
    ],
    "fieldRules": {
      "Age": [
        "self >= 18"
      ],
      "Name": [
        "self != \"\"",
        "self.size() < 50"
      ],
      "Password": [
        "self != \"\""
      ],
      "PasswordConfirm": [
        "self != \"\""
      ]
    }
  }
}
```

### 利用側のコード (`main.go`)

アプリケーションは、このJSONファイルを指定して `JSONRuleProvider` を作成し、Validatorに渡す必要があります。

```go
package main

import (
    "fmt"
    "log"

    "github.com/podhmo/veritas"
    "your-project/models"
)

func main() {
    // 1. JSONファイルからルールプロバイダーを作成
    provider, err := veritas.NewJSONRuleProvider("rules.json")
    if err != nil {
        log.Fatalf("Failed to create rule provider: %v", err)
    }

    // 2. プロバイダーを渡してValidatorを初期化
    validator, err := veritas.NewValidator(provider)
    if err != nil {
        log.Fatalf("Failed to create validator: %v", err)
    }

    // 3. 検証を実行
    user := models.User{ /* ... */ }
    if err := validator.Validate(user); err != nil {
        fmt.Printf("Validation failed: %v\n", err)
    }
}
```

### 利点と欠点

- **利点**: ルールをアプリケーションの再コンパイルなしで変更可能。
- **欠点**:
    - **実行時エラー**: `models.User` の `Name` フィールドを `Username` に変更しても、`rules.json` は古いままなので、実行するまでエラーに気づけない。
    - **パフォーマンス**: 起動時にファイルI/OとJSONパースのコストがかかる。
    - **IDEサポートの欠如**: `rules.json` 内の `"Name"` はただの文字列であり、`User.Name` フィールドとの関連性はIDEには分からない。

---

## 2. Goコード生成アプローチ (提案)

CLIツールはJSONの代わりに、検証ルールを定義したGoのソースコード（例: `generated_rules.go`）を生成します。このファイルはアプリケーションの他のソースコードと一緒にコンパイルされます。

### 生成されるファイル (`generated_rules.go`)

`veritas -in ./models --format=go -out models/generated_rules.go` を実行すると、以下のGoソースファイルが生成されます。

```go
// Code generated by veritas. DO NOT EDIT.
package models

import (
	"github.com/podhmo/veritas"
)

func init() {
	veritas.Register("models.User", veritas.ValidationRuleSet{
		TypeRules: []string{
			"self.Password == self.PasswordConfirm",
		},
		FieldRules: map[string][]string{
			"Age": {
				"self >= 18",
			},
			"Name": {
				"self != \"\"",
				"self.size() < 50",
			},
			"Password": {
				"self != \"\"",
			},
			"PasswordConfirm": {
				"self != \"\"",
			},
		},
	})
}
```

### 利用側のコード (`main.go`)

生成されたGoコードは `init()` 関数を持つため、ルールの登録は自動的に行われます。利用側は `RuleProvider` を意識する必要がなく、よりシンプルになります。

```go
package main

import (
    "fmt"
    "log"

    "github.com/podhmo/veritas"
    "your-project/models"
    _ "your-project/models" // `init()`を確実に呼び出すためにimport
)

func main() {
    // 1. Validatorを直接初期化 (プロバイダーは不要)
    //    `models`パッケージの`init()`が自動でルールを登録済み
    validator, err := veritas.NewValidator()
    if err != nil {
        log.Fatalf("Failed to create validator: %v", err)
    }

    // 2. 検証を実行
    user := models.User{ /* ... */ }
    if err := validator.Validate(user); err != nil {
        fmt.Printf("Validation failed: %v\n", err)
    }
}
```
*Note: `_ "your-project/models"` のように空インポートするのは、`main`パッケージから`models.User`などの型を直接利用しない場合でも、`models`パッケージの`init()`関数を確実に実行させるためのGoの作法です。*

### 利点と欠点

- **利点**:
    - **コンパイル時安全性**: `models.User` の `Name` フィールドを `Username` に変更した場合、もしコードジェネレータが賢く追随できなければ、古い `generated_rules.go` は存在しないフィールドを参照しようとするため、**コンパイルエラー**となり、問題を即座に発見できる（理想的にはジェネレータが追随する）。
    - **パフォーマンス**: 実行時のオーバーヘッドがほぼゼロ。
    - **IDEサポート**: `veritas.Register` の引数などは通常のGoコードとして扱われる。
- **欠点**: ルールを変更した場合は、コードを再生成して再コンパイルする必要がある。

---

## 結論

| 特徴 | JSONアプローチ | Goコード生成アプローチ |
|:---|:---:|:---:|
| **型安全性** | 実行時 | **コンパイル時** |
| **パフォーマンス** | 低〜中 | **高** |
| **IDEサポート** | 限定的 | **完全** |
| **デバッグ** | 困難 | **容易** |
| **実装の容易さ** | **容易** | 複雑 |
| **動的な更新** | **可能** | 不可 |

Goはその強力な型システムとコンパイル時の安全性に大きな利点がある言語です。**Goコード生成アプローチ**は、その哲学と一致しており、より堅牢で、パフォーマンスが高く、開発者体験（DX）に優れたソリューションを提供します。

アプリケーションの安全性を最優先に考えるならば、コンパイル時に問題を検出できるGoコード生成アプローチが明らかに優れています。ビルドプロセスに一手間加わるというデメリットは、`go generate`の活用によって十分に緩和できます。

したがって、`veritas`のコア機能として、**Goコード生成を主要なアプローチとして推奨します**。JSONアプローチも、特定のユースケース（例: 他の言語との連携）のためにオプションとして残すことは考えられますが、デフォルトかつ推奨されるべきはGoコード生成です。
