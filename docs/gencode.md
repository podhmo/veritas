# アプローチの比較: JSON vs Goコード生成

`veritas`ライブラリにおける検証ルールの提供方法として、2つの主要なアプローチが考えられます。1つは現在実装されている、ルールをJSONファイルとして生成・ロードする方法です。もう1つは、ルールをGoのソースコードとして直接生成する方法です。

このドキュメントでは、両方のアプローチの利点と欠点を比較し、将来的な方針を検討します。

---

## 1. JSONアプローチ (現在の手法)

このアプローチでは、CLIツールがGoのソースコードを静的解析し、検証ルールをJSONファイルに出力します。アプリケーションの起動時に、ライブラリはこのJSONファイルを読み込み、パースして、検証ルールをメモリ上に展開します。

### 利点

- **動的なルールの更新**: アプリケーションを再コンパイルすることなく、JSONファイルを変更するだけで検証ロジックを更新できます。
- **言語からの独立性**: JSONは広くサポートされているフォーマットであるため、Go以外の言語やツールでもルールを解析・利用できる可能性があります。
- **実装の単純さ**: Goの構造体をJSONにシリアライズするのは比較的簡単で、標準ライブラリでサポートされています。

### 欠点

- **実行時エラー**: ルールとGoの構造体の間に不整合（例: フィールド名のタイポ、型の変更）があった場合、コンパイル時には検出できず、実行時になって初めてエラーが発覚します。
- **パフォーマンスのオーバーヘッド**: アプリケーションの起動ごとに、ファイルのI/OとJSONのデシリアライズ処理が発生します。ルールの数が増えると、このオーバーヘッドは無視できなくなる可能性があります。
- **IDEサポートの欠如**: ルールはただの文字列としてJSONに格納されるため、IDEによるコード補完、リファクタリング、定義ジャンプなどのサポートは受けられません。
- **デバッグの困難さ**: 検証ロジックはライブラリ内部で動的に解釈・実行されるため、特定のルールがなぜ失敗したのかをデバッガでステップ実行して追跡するのが困難です。

---

## 2. Goコード生成アプローチ (提案)

このアプローチでは、CLIツールはJSONファイルの代わりに、検証ルールを定義したGoのソースコード（例: `generated_rules.go`）を生成します。このファイルはアプリケーションの他のソースコードと一緒にコンパイルされます。

### 生成されるコードの例

`testdata/sources/user.go` の `MockUser` を例にすると、生成されるGoコードは以下のようになります。

```go
// Code generated by veritas. DO NOT EDIT.

package main // or a user-defined package

import (
	"github.com/podhmo/veritas"
)

func init() {
	// Registering rules for type: sources.MockUser
	veritas.Register("sources.MockUser", veritas.ValidationRuleSet{
		TypeRules: []string{
			"self.Age >= 18",
		},
		FieldRules: map[string][]string{
			"Name": {
				"self != \"\"", // from "nonzero"
			},
			"Email": {
				"self != \"\"", // from "nonzero"
				"self.matches('^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$')", // from "email"
			},
			"ID": {
				"self != nil", // from "required"
			},
		},
	})

	// ... Register rules for other structs (MockVariety, etc.)
}
```

### 利点

- **コンパイル時の型安全性**: 生成されたGoコードはコンパイラによって型チェックされます。もし検証対象の構造体からフィールドが削除されたり、名前が変更されたりすれば、生成されたコードはコンパイルエラーとなり、不整合を早期に検出できます。
- **高いパフォーマンス**: ファイルI/OやJSONパースのオーバーヘッドがありません。ルールは`init()`関数によってプログラムの初期化時に静的に登録されるため、非常に高速です。
- **完全なIDEサポート**: 生成されたコードは通常のGoコードであるため、IDEの機能を最大限に活用できます。ルールの定義元へジャンプしたり、使用箇所を検索したりすることが容易になります。
- **デバッグの容易さ**: 検証ロジックがコードとして存在するため、ブレークポイントを設定してデバッガでステップ実行するなど、通常のGoコードと同じようにデバッグできます。

### 欠点

- **ビルドプロセスへの一手間**: コード生成というステップが開発ワークフローに加わります。`go generate`などを利用して自動化することが推奨されます。
- **実装の複雑化**: Goのソースコードを生成するロジック（`go/ast`や`go/format`などを使ったコード生成）は、JSONを生成するよりも複雑になります。
- **動的な更新の不可**: ルールを変更した場合は、必ず再コンパイルが必要になります。

---

## 結論

| 特徴 | JSONアプローチ | Goコード生成アプローチ |
|:---|:---:|:---:|
| **型安全性** | 実行時 | **コンパイル時** |
| **パフォーマンス** | 低〜中 | **高** |
| **IDEサポート** | 限定的 | **完全** |
| **デバッグ** | 困難 | **容易** |
| **実装の容易さ** | **容易** | 複雑 |
| **動的な更新** | **可能** | 不可 |

Goはその強力な型システムとコンパイル時の安全性に大きな利点がある言語です。**Goコード生成アプローチ**は、その哲学と一致しており、より堅牢で、パフォーマンスが高く、開発者体験（DX）に優れたソリューションを提供します。

アプリケーションの安全性を最優先に考えるならば、コンパイル時に問題を検出できるGoコード生成アプローチが明らかに優れています。ビルドプロセスに一手間加わるというデメリットは、`go generate`の活用によって十分に緩和できます。

したがって、`veritas`のコア機能として、**Goコード生成を主要なアプローチとして推奨します**。JSONアプローチも、特定のユースケース（例: 他の言語との連携）のためにオプションとして残すことは考えられますが、デフォルトかつ推奨されるべきはGoコード生成です。
