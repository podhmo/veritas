# Approach Comparison: JSON vs. Go Code Generation

There are two primary approaches for providing validation rules in the `veritas` library. The first is the currently implemented method of generating and loading rules from a JSON file. The second is to generate Go source code directly.

This document compares both approaches with concrete code examples to consider the future direction.

---

## Prerequisite for Comparison: The Go Struct

We will use the following `models.User` struct as the input to see how each approach handles and utilizes validation rules.

```go
// file: models/user.go
package models

// @cel: self.Password == self.PasswordConfirm
type User struct {
    Name     string `validate:"required,cel:self.size() < 50"`
    Age      int    `validate:"cel:self >= 18"`
    Password string `validate:"required"`
    PasswordConfirm string `validate:"required"`
}
```

---

## 1. JSON-based Approach (Current Method)

The CLI tool statically analyzes Go source code and outputs the validation rules to a JSON file. The application reads this JSON file at runtime.

### Generated File (`rules.json`)

Running `veritas -in ./models -out rules.json` generates the following JSON:

```json
{
  "models.User": {
    "typeRules": [
      "self.Password == self.PasswordConfirm"
    ],
    "fieldRules": {
      "Age": [
        "self >= 18"
      ],
      "Name": [
        "self != \"\"",
        "self.size() < 50"
      ],
      "Password": [
        "self != \"\""
      ],
      "PasswordConfirm": [
        "self != \"\""
      ]
    }
  }
}
```

### Consumer Code (`main.go`)

The application must create a `JSONRuleProvider` by specifying the JSON file and pass it to the validator.

```go
package main

import (
    "fmt"
    "log"

    "github.com/podhmo/veritas"
    "your-project/models"
)

func main() {
    // 1. Create a rule provider from the JSON file
    provider, err := veritas.NewJSONRuleProvider("rules.json")
    if err != nil {
        log.Fatalf("Failed to create rule provider: %v", err)
    }

    // 2. Initialize the validator by passing the provider
    validator, err := veritas.NewValidator(provider)
    if err != nil {
        log.Fatalf("Failed to create validator: %v", err)
    }

    // 3. Perform validation
    user := models.User{ /* ... */ }
    if err := validator.Validate(user); err != nil {
        fmt.Printf("Validation failed: %v\n", err)
    }
}
```

### Pros and Cons

- **Pros**: Rules can be updated without recompiling the application.
- **Cons**:
    - **Runtime Errors**: If the `Name` field in `models.User` is renamed to `Username`, the `rules.json` file remains unchanged, and the error will only be discovered at runtime.
    - **Performance**: Incurs file I/O and JSON parsing costs at startup.
    - **Lack of IDE Support**: The `"Name"` key in `rules.json` is just a string; the IDE has no awareness of its relationship to the `User.Name` field.

---

## 2. Go Code Generation Approach (Proposed)

Instead of a JSON file, the CLI tool generates a Go source file (e.g., `generated_rules.go`) that defines the validation rules. This file is compiled along with the rest of the application's source code.

### Generated File (`generated_rules.go`)

Running `veritas -in ./models --format=go -out models/generated_rules.go` generates the following Go source file:

```go
// Code generated by veritas. DO NOT EDIT.
package models

import (
	"github.comcom/podhmo/veritas"
)

func init() {
	veritas.Register("models.User", veritas.ValidationRuleSet{
		TypeRules: []string{
			"self.Password == self.PasswordConfirm",
		},
		FieldRules: map[string][]string{
			"Age": {
				"self >= 18",
			},
			"Name": {
				"self != \"\"",
				"self.size() < 50",
			},
			"Password": {
				"self != \"\"",
			},
			"PasswordConfirm": {
				"self != \"\"",
			},
		},
	})
}
```

### Consumer Code (`main.go`)

Since the generated Go code has an `init()` function, rule registration is automatic. The consumer code no longer needs to be aware of the `RuleProvider`, making it simpler.

```go
package main

import (
    "fmt"
    "log"

    "github.com/podhmo/veritas"
    "your-project/models"
    _ "your-project/models" // Blank import to ensure init() is called
)

func main() {
    // 1. Initialize the validator directly (no provider needed)
    //    The init() function in the `models` package has already registered the rules.
    validator, err := veritas.NewValidator()
    if err != nil {
        log.Fatalf("Failed to create validator: %v", err)
    }

    // 2. Perform validation
    user := models.User{ /* ... */ }
    if err := validator.Validate(user); err != nil {
        fmt.Printf("Validation failed: %v\n", err)
    }
}
```
*Note: A blank import like `_ "your-project/models"` is a Go idiom to ensure the `init()` function of the `models` package is executed, even if no types from the package are directly used in the `main` package.*

### Pros and Cons

- **Pros**:
    - **Compile-Time Safety**: If the `Name` field in `models.User` is renamed to `Username`, the old `generated_rules.go` would try to reference a non-existent field, resulting in a **compile-time error**. This allows for immediate problem detection. (Ideally, the generator would update the code accordingly.)
    - **Performance**: Near-zero runtime overhead.
    - **IDE Support**: Arguments to `veritas.Register` are treated as regular Go code.
- **Cons**: Changing rules requires regenerating the code and recompiling.

---

## Conclusion

| Feature | JSON Approach | Go Code Generation |
|:---|:---:|:---:|
| **Type Safety** | Runtime | **Compile-Time** |
| **Performance** | Low-Medium | **High** |
| **IDE Support** | Limited | **Full** |
| **Debugging** | Difficult | **Easy** |
| **Ease of Implementation** | **Easy** | Complex |
| **Dynamic Updates** | **Possible** | Not Possible |

Go is a language that benefits greatly from its strong type system and compile-time safety. The **Go Code Generation approach** aligns with this philosophy, offering a more robust, performant, and developer-friendly (DX) solution.

If application safety is the top priority, the Go code generation approach is clearly superior, as it allows problems to be detected at compile time. The disadvantage of adding a step to the build process can be easily mitigated by using `go generate`.

Therefore, **Go code generation is recommended as the primary approach** for `veritas`. The JSON approach could be retained as an option for specific use cases (e.g., interoperability with other languages), but Go code generation should be the default and recommended method.
